"""
üîß Diagnostic complet Azure SQL Database
Flask Incidents R√©seau - Version Azure

Ce script effectue tous les tests de diagnostic pour Azure SQL Database
"""

import os
import sys
import time
import pyodbc
from datetime import datetime
from sqlalchemy import create_engine, text
from sqlalchemy.exc import SQLAlchemyError

# Charger les variables d'environnement depuis le fichier .env
try:
    from dotenv import load_dotenv
    load_dotenv()
    print("üîß Variables d'environnement charg√©es depuis .env")
except ImportError:
    print("‚ö†Ô∏è  python-dotenv non install√©, utilisation des variables syst√®me uniquement")

def print_banner():
    """Affiche la banni√®re de diagnostic"""
    print("=" * 80)
    print("üîß DIAGNOSTIC AZURE SQL DATABASE")
    print("Flask Incidents R√©seau - Version Cloud Azure")
    print("=" * 80)
    print(f"üìÖ Date: {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}")
    print(f"üêç Python: {sys.version.split()[0]}")
    print(f"üíª OS: {os.name}")
    print("=" * 80)

def check_environment_variables():
    """V√©rifie les variables d'environnement"""
    print("üîç 1. V√âRIFICATION DES VARIABLES D'ENVIRONNEMENT")
    print("-" * 50)
    
    required_vars = {
        'AZURE_SQL_SERVER': 'Serveur Azure SQL',
        'AZURE_SQL_DATABASE': 'Base de donn√©es',
        'AZURE_SQL_USERNAME': 'Nom d\'utilisateur',
        'AZURE_SQL_PASSWORD': 'Mot de passe'
    }
    
    missing_vars = []
    
    for var, description in required_vars.items():
        value = os.getenv(var)
        if value:
            if var == 'AZURE_SQL_PASSWORD':
                print(f"‚úÖ {description}: {'*' * len(value)}")
            else:
                print(f"‚úÖ {description}: {value}")
        else:
            print(f"‚ùå {description}: MANQUANT")
            missing_vars.append(var)
    
    print()
    return len(missing_vars) == 0, missing_vars

def check_pyodbc_drivers():
    """V√©rifie les drivers ODBC disponibles"""
    print("üîç 2. V√âRIFICATION DES DRIVERS ODBC")
    print("-" * 50)
    
    try:
        drivers = pyodbc.drivers()
        print(f"üìä {len(drivers)} driver(s) ODBC trouv√©(s):")
        
        for i, driver in enumerate(drivers, 1):
            print(f"   {i}. {driver}")
        
        # V√©rifier la pr√©sence du driver SQL Server
        sql_server_drivers = [d for d in drivers if 'SQL Server' in d]
        
        if sql_server_drivers:
            print(f"\n‚úÖ Driver SQL Server disponible: {sql_server_drivers[0]}")
            return True, sql_server_drivers[0]
        else:
            print("\n‚ùå Aucun driver SQL Server trouv√©")
            return False, None
            
    except Exception as e:
        print(f"‚ùå Erreur lors de la v√©rification des drivers: {e}")
        return False, None

def test_basic_connection():
    """Test de connexion basique avec pyodbc"""
    print("üîç 3. TEST DE CONNEXION BASIQUE (pyodbc)")
    print("-" * 50)
    
    server = os.getenv('AZURE_SQL_SERVER')
    database = os.getenv('AZURE_SQL_DATABASE')
    username = os.getenv('AZURE_SQL_USERNAME')
    password = os.getenv('AZURE_SQL_PASSWORD')
    
    connection_string = (
        f"DRIVER={{ODBC Driver 18 for SQL Server}};"
        f"SERVER={server};"
        f"DATABASE={database};"
        f"UID={username};"
        f"PWD={password};"
        f"Encrypt=yes;"
        f"TrustServerCertificate=no;"
        f"Connection Timeout=30;"
    )
    
    try:
        print(f"üì° Tentative de connexion √† {server}...")
        start_time = time.time()
        
        conn = pyodbc.connect(connection_string)
        connection_time = time.time() - start_time
        
        print(f"‚úÖ Connexion r√©ussie en {connection_time:.2f}s")
        
        # Test d'une requ√™te simple
        cursor = conn.cursor()
        cursor.execute("SELECT @@VERSION")
        version = cursor.fetchone()[0]
        
        print(f"üìä Version SQL Server: {version[:80]}...")
        
        # Test de performance
        cursor.execute("SELECT GETDATE()")
        current_time = cursor.fetchone()[0]
        print(f"üïí Heure serveur: {current_time}")
        
        cursor.close()
        conn.close()
        
        return True, connection_time
        
    except Exception as e:
        print(f"‚ùå Erreur de connexion: {e}")
        return False, 0

def test_sqlalchemy_connection():
    """Test de connexion avec SQLAlchemy"""
    print("üîç 4. TEST DE CONNEXION SQLALCHEMY")
    print("-" * 50)
    
    server = os.getenv('AZURE_SQL_SERVER')
    database = os.getenv('AZURE_SQL_DATABASE')
    username = os.getenv('AZURE_SQL_USERNAME')
    password = os.getenv('AZURE_SQL_PASSWORD')
    
    connection_string = (
        f"mssql+pyodbc://{username}:{password}@{server}/{database}"
        f"?driver=ODBC+Driver+18+for+SQL+Server"
        f"&Encrypt=yes"
        f"&TrustServerCertificate=no"
        f"&Connection+Timeout=30"
    )
    
    try:
        print("üì° Cr√©ation du moteur SQLAlchemy...")
        engine = create_engine(connection_string, echo=False)
        
        start_time = time.time()
        with engine.connect() as conn:
            connection_time = time.time() - start_time
            
            print(f"‚úÖ Connexion SQLAlchemy r√©ussie en {connection_time:.2f}s")
            
            # Test des m√©tadonn√©es
            result = conn.execute(text("SELECT COUNT(*) FROM INFORMATION_SCHEMA.TABLES WHERE TABLE_TYPE='BASE TABLE'"))
            table_count = result.scalar()
            print(f"üìä Nombre de tables: {table_count}")
            
            # Test de la table incidents
            try:
                result = conn.execute(text("SELECT COUNT(*) FROM incidents"))
                incident_count = result.scalar()
                print(f"üìã Nombre d'incidents: {incident_count}")
            except:
                print("‚ö†Ô∏è  Table 'incidents' non trouv√©e (normale si pas encore initialis√©e)")
        
        return True, connection_time
        
    except SQLAlchemyError as e:
        print(f"‚ùå Erreur SQLAlchemy: {e}")
        return False, 0
    except Exception as e:
        print(f"‚ùå Erreur inattendue: {e}")
        return False, 0

def test_azure_connectivity():
    """Test de connectivit√© r√©seau vers Azure"""
    print("üîç 5. TEST DE CONNECTIVIT√â R√âSEAU AZURE")
    print("-" * 50)
    
    server = os.getenv('AZURE_SQL_SERVER')
    
    if not server:
        print("‚ùå Serveur Azure non configur√©")
        return False
    
    # Extraire le nom du serveur sans le port
    server_name = server.split('.')[0] if '.' in server else server
    
    try:
        import socket
        
        print(f"üåê Test de r√©solution DNS: {server}")
        
        # R√©solution DNS
        start_time = time.time()
        ip_address = socket.gethostbyname(server.split(',')[0])  # Enlever le port si pr√©sent
        dns_time = time.time() - start_time
        
        print(f"‚úÖ R√©solution DNS r√©ussie en {dns_time:.3f}s")
        print(f"üìç Adresse IP: {ip_address}")
        
        # Test de connexion TCP sur le port 1433
        print(f"üîå Test de connexion TCP sur le port 1433...")
        
        start_time = time.time()
        sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
        sock.settimeout(10)
        result = sock.connect_ex((server.split(',')[0], 1433))
        tcp_time = time.time() - start_time
        sock.close()
        
        if result == 0:
            print(f"‚úÖ Connexion TCP r√©ussie en {tcp_time:.3f}s")
            return True
        else:
            print(f"‚ùå Connexion TCP √©chou√©e (code: {result})")
            return False
            
    except socket.gaierror as e:
        print(f"‚ùå Erreur de r√©solution DNS: {e}")
        return False
    except Exception as e:
        print(f"‚ùå Erreur de connectivit√©: {e}")
        return False

def test_database_operations():
    """Test des op√©rations de base de donn√©es"""
    print("üîç 6. TEST DES OP√âRATIONS DE BASE DE DONN√âES")
    print("-" * 50)
    
    server = os.getenv('AZURE_SQL_SERVER')
    database = os.getenv('AZURE_SQL_DATABASE')
    username = os.getenv('AZURE_SQL_USERNAME')
    password = os.getenv('AZURE_SQL_PASSWORD')
    
    connection_string = (
        f"mssql+pyodbc://{username}:{password}@{server}/{database}"
        f"?driver=ODBC+Driver+18+for+SQL+Server"
        f"&Encrypt=yes"
        f"&TrustServerCertificate=no"
        f"&Connection+Timeout=30"
    )
    
    try:
        engine = create_engine(connection_string)
        
        with engine.connect() as conn:
            # Test 1: Lecture des m√©tadonn√©es
            print("üìä Test 1: Lecture des m√©tadonn√©es...")
            result = conn.execute(text("""
                SELECT 
                    TABLE_SCHEMA,
                    TABLE_NAME,
                    TABLE_TYPE
                FROM INFORMATION_SCHEMA.TABLES 
                WHERE TABLE_TYPE = 'BASE TABLE'
                ORDER BY TABLE_NAME
            """))
            
            tables = result.fetchall()
            print(f"   ‚úÖ {len(tables)} table(s) trouv√©e(s)")
            
            for table in tables:
                print(f"      üìã {table[1]} (Sch√©ma: {table[0]})")
            
            # Test 2: V√©rification de la table incidents
            print("\nüìã Test 2: V√©rification table incidents...")
            try:
                result = conn.execute(text("""
                    SELECT 
                        COLUMN_NAME,
                        DATA_TYPE,
                        IS_NULLABLE
                    FROM INFORMATION_SCHEMA.COLUMNS 
                    WHERE TABLE_NAME = 'incidents'
                    ORDER BY ORDINAL_POSITION
                """))
                
                columns = result.fetchall()
                if columns:
                    print(f"   ‚úÖ Table incidents trouv√©e avec {len(columns)} colonnes:")
                    for col in columns:
                        nullable = "NULL" if col[2] == "YES" else "NOT NULL"
                        print(f"      üìÑ {col[0]} ({col[1]}) - {nullable}")
                else:
                    print("   ‚ö†Ô∏è  Table incidents non trouv√©e")
                
                # Test 3: Lecture des donn√©es
                print("\nüìä Test 3: Lecture des donn√©es incidents...")
                result = conn.execute(text("SELECT COUNT(*) FROM incidents"))
                count = result.scalar()
                print(f"   ‚úÖ {count} incident(s) dans la base")
                
                if count > 0:
                    result = conn.execute(text("""
                        SELECT TOP 3 
                            id, 
                            titre, 
                            severite,
                            date_incident
                        FROM incidents 
                        ORDER BY date_incident DESC
                    """))
                    
                    recent_incidents = result.fetchall()
                    print("   üìã Derniers incidents:")
                    for inc in recent_incidents:
                        print(f"      üî∏ #{inc[0]}: {inc[1]} ({inc[2]})")
                
            except Exception as e:
                print(f"   ‚ùå Erreur sur la table incidents: {e}")
            
            print("\n‚úÖ Tests d'op√©rations de base de donn√©es termin√©s")
            return True
            
    except Exception as e:
        print(f"‚ùå Erreur lors des tests de base de donn√©es: {e}")
        return False

def generate_report(results):
    """G√©n√®re un rapport de diagnostic"""
    print("\n" + "=" * 80)
    print("üìä RAPPORT DE DIAGNOSTIC")
    print("=" * 80)
    
    total_tests = len(results)
    passed_tests = sum(1 for r in results.values() if r)
    
    print(f"üéØ Tests r√©ussis: {passed_tests}/{total_tests}")
    print(f"üìä Taux de r√©ussite: {(passed_tests/total_tests)*100:.1f}%")
    print()
    
    for test_name, result in results.items():
        status = "‚úÖ SUCC√àS" if result else "‚ùå √âCHEC"
        print(f"   {status}: {test_name}")
    
    print("\n" + "=" * 80)
    
    if passed_tests == total_tests:
        print("üéâ DIAGNOSTIC COMPLET: Votre configuration Azure SQL est op√©rationnelle !")
        print("üöÄ Vous pouvez lancer l'application Flask avec: python app.py")
    else:
        print("‚ö†Ô∏è  DIAGNOSTIC PARTIEL: Certains tests ont √©chou√©")
        print("üîß Consultez les d√©tails ci-dessus pour r√©soudre les probl√®mes")
    
    print("=" * 80)

def main():
    """Fonction principale de diagnostic"""
    print_banner()
    
    results = {}
    
    # Test 1: Variables d'environnement
    env_ok, missing_vars = check_environment_variables()
    results["Variables d'environnement"] = env_ok
    
    if not env_ok:
        print(f"\n‚ùå Variables manquantes: {', '.join(missing_vars)}")
        print("üîß Configurez ces variables avant de continuer")
        print("=" * 80)
        return
    
    print()
    
    # Test 2: Drivers ODBC
    drivers_ok, driver = check_pyodbc_drivers()
    results["Drivers ODBC"] = drivers_ok
    print()
    
    if not drivers_ok:
        print("‚ùå Installez ODBC Driver 18 for SQL Server avant de continuer")
        print("=" * 80)
        return
    
    # Test 3: Connectivit√© r√©seau
    network_ok = test_azure_connectivity()
    results["Connectivit√© r√©seau"] = network_ok
    print()
    
    # Test 4: Connexion basique
    basic_ok, basic_time = test_basic_connection()
    results["Connexion pyodbc"] = basic_ok
    print()
    
    # Test 5: Connexion SQLAlchemy
    sqlalchemy_ok, sqlalchemy_time = test_sqlalchemy_connection()
    results["Connexion SQLAlchemy"] = sqlalchemy_ok
    print()
    
    # Test 6: Op√©rations de base de donn√©es
    if basic_ok and sqlalchemy_ok:
        operations_ok = test_database_operations()
        results["Op√©rations de base de donn√©es"] = operations_ok
        print()
    else:
        results["Op√©rations de base de donn√©es"] = False
    
    # G√©n√©ration du rapport final
    generate_report(results)

if __name__ == "__main__":
    try:
        main()
    except KeyboardInterrupt:
        print("\n\n‚èπÔ∏è  Diagnostic interrompu par l'utilisateur")
    except Exception as e:
        print(f"\n\n‚ùå Erreur inattendue: {e}")
        import traceback
        traceback.print_exc()